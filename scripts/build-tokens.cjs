#!/usr/bin/env node

/**
 * Build Script for @wex/design-tokens
 * 
 * Reads design-tokens.json and generates all format exports:
 * - CSS (design-tokens.css, shadcn-bridge.css, components-bridge.css, index.css)
 * - SCSS (design-tokens.scss, shadcn-bridge.scss, components-bridge.scss, index.scss)
 * - TypeScript (design-tokens.ts)
 * - JSON (design-tokens.json)
 * - iOS/Android (via Style Dictionary)
 * 
 * Outputs directly to package root directories: css/, scss/, ios/, android/
 */

const fs = require('fs');
const path = require('path');

const DESIGN_TOKENS_DIR = path.join(__dirname, '..', 'packages', 'design-tokens');
const DESIGN_TOKENS_JSON_PATH = path.join(DESIGN_TOKENS_DIR, 'design-tokens.json');
const CSS_DIR = path.join(DESIGN_TOKENS_DIR, 'css');
const SCSS_DIR = path.join(DESIGN_TOKENS_DIR, 'scss');
const IOS_DIR = path.join(DESIGN_TOKENS_DIR, 'ios');
const ANDROID_DIR = path.join(DESIGN_TOKENS_DIR, 'android');
const BRIDGES_ROOT_DIR = DESIGN_TOKENS_DIR; // Bridge files are now at root

// Ensure directories exist
function ensureDir(dir) {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
}

// Read design-tokens.json
function readTheme() {
  if (!fs.existsSync(DESIGN_TOKENS_JSON_PATH)) {
    console.error(`Error: design-tokens.json not found at ${DESIGN_TOKENS_JSON_PATH}`);
    process.exit(1);
  }
  return JSON.parse(fs.readFileSync(DESIGN_TOKENS_JSON_PATH, 'utf8'));
}

// Convert HSL value to SCSS hsl() format
function hslToSCSS(value) {
  // If it's already in HSL format "H S% L%", convert to SCSS format
  if (/^\d+\s+\d+%\s+\d+%$/.test(value)) {
    const [h, s, l] = value.split(/\s+/);
    return `hsl(${h}, ${s}, ${l})`;
  }
  // If it's a CSS variable reference, keep as-is (but convert var() to SCSS variable reference)
  if (value.startsWith('var(')) {
    return value;
  }
  // If it's a font stack or other string, wrap in quotes
  if (value.includes(',') && !value.includes('var(')) {
    return `"${value}"`;
  }
  // Otherwise return as-is (px, numbers, etc.)
  return value;
}

// Convert CSS custom property to SCSS variable
function cssVarToSCSSVar(cssVar) {
  // Convert --wex-primary to $wex-primary
  return cssVar.replace(/^--/, '$');
}

// Generate CSS from theme
function generateCSS(theme) {
  let css = `/* ============================================================
   WEX TOKEN EMISSION LAYER
   ============================================================
   This file contains ALL WEX design tokens as CSS variables.
   
   AUTO-GENERATED by build script - DO NOT EDIT
   ============================================================ */

:root {
`;

  // Light mode tokens
  Object.entries(theme.light)
    .sort(([a], [b]) => a.localeCompare(b))
    .forEach(([token, value]) => {
      css += `  ${token}: ${value};\n`;
    });

  css += `}

.dark {
`;

  // Dark mode tokens
  Object.entries(theme.dark)
    .sort(([a], [b]) => a.localeCompare(b))
    .forEach(([token, value]) => {
      css += `  ${token}: ${value};\n`;
    });

  css += `}
`;

  return css;
}

// Generate SCSS variables from theme
function generateSCSS(theme) {
  let scss = `/* ============================================================
   WEX TOKEN EMISSION LAYER (SCSS)
   ============================================================
   This file contains ALL WEX design tokens as SCSS variables.
   
   AUTO-GENERATED by build script - DO NOT EDIT
   ============================================================ */

// Light mode tokens
`;

  // Light mode tokens as SCSS variables
  Object.entries(theme.light)
    .sort(([a], [b]) => a.localeCompare(b))
    .forEach(([token, value]) => {
      const scssVar = cssVarToSCSSVar(token);
      const scssValue = hslToSCSS(value);
      scss += `${scssVar}: ${scssValue};\n`;
    });

  scss += `\n// Dark mode tokens\n.dark {\n`;

  // Dark mode tokens as SCSS variables (for use in .dark context)
  Object.entries(theme.dark)
    .sort(([a], [b]) => a.localeCompare(b))
    .forEach(([token, value]) => {
      const scssVar = cssVarToSCSSVar(token);
      const scssValue = hslToSCSS(value);
      scss += `  ${scssVar}: ${scssValue};\n`;
    });

  scss += `}\n`;

  return scss;
}

// Convert CSS bridge file to SCSS
function cssBridgeToSCSS(cssContent) {
  // Convert all CSS custom properties to SCSS variables
  // Convert --variable-name to $variable-name
  // Convert var(--wex-*) references to $wex-* SCSS variable references
  
  let scss = cssContent;
  
  // First, convert all var() references to SCSS variable references
  scss = scss.replace(/var\(--(wex-[^)]+)\)/g, (match, varName) => {
    return `$${varName}`;
  });
  
  scss = scss.replace(/var\(--(wex-component-[^)]+)\)/g, (match, varName) => {
    return `$${varName}`;
  });
  
  // Then convert CSS custom property declarations to SCSS variables
  // Pattern: --variable-name: value; (must match the full declaration)
  scss = scss.replace(/^(\s*)--([a-zA-Z0-9-]+):\s*([^;]+);/gm, (match, indent, varName, value) => {
    // Convert variable name
    const scssVar = `$${varName.trim()}`;
    
    // Value should already have var() converted, but handle raw HSL if needed
    let scssValue = value.trim();
    
    // If value is a raw HSL format "H S% L%", convert it
    if (/^\d+\s+\d+%\s+\d+%$/.test(scssValue)) {
      const [h, s, l] = scssValue.split(/\s+/);
      scssValue = `hsl(${h}, ${s}, ${l})`;
    }
    
    return `${indent}${scssVar}: ${scssValue};`;
  });
  
  return scss;
}

// Generate TypeScript from theme
function generateTypeScript(theme) {
  const convertTokenName = (token) => {
    // Remove --wex- prefix
    let name = token.replace('--wex-', '');
    // Convert kebab-case to camelCase, handling numbers
    name = name.replace(/-([a-z0-9])/g, (_, char) => char.toUpperCase());
    // Ensure first character is lowercase
    name = name.replace(/^[A-Z]/, (letter) => letter.toLowerCase());
    return name;
  };

  const lightTokens = {};
  const darkTokens = {};

  Object.entries(theme.light).forEach(([token, value]) => {
    const key = convertTokenName(token);
    lightTokens[key] = value;
  });

  Object.entries(theme.dark).forEach(([token, value]) => {
    const key = convertTokenName(token);
    darkTokens[key] = value;
  });

  return `/**
 * WEX Design Tokens
 * 
 * AUTO-GENERATED by build script - DO NOT EDIT
 */

export const tokens = {
  light: ${JSON.stringify(lightTokens, null, 2)},
  dark: ${JSON.stringify(darkTokens, null, 2)},
} as const;

export type Tokens = typeof tokens;
`;
}

// Copy bridge files from root to output directories
function copyBridgeFiles() {
  const bridgeFiles = [
    { name: 'shadcn-bridge', cssExt: 'css', scssExt: 'scss' },
    { name: 'components-bridge', cssExt: 'css', scssExt: 'scss' },
  ];

  bridgeFiles.forEach(({ name, cssExt, scssExt }) => {
    const srcFile = path.join(BRIDGES_ROOT_DIR, `${name}.${cssExt}`);
    
    if (fs.existsSync(srcFile)) {
      const content = fs.readFileSync(srcFile, 'utf8');
      
      // Copy to CSS directory
      fs.writeFileSync(path.join(CSS_DIR, `${name}.${cssExt}`), content);
      
      // Convert to SCSS and write to SCSS directory
      const scssContent = cssBridgeToSCSS(content);
      fs.writeFileSync(path.join(SCSS_DIR, `${name}.${scssExt}`), scssContent);
    } else {
      console.warn(`  ⚠ Warning: ${srcFile} not found, skipping bridge file`);
    }
  });
}

// Generate index files
function generateIndexFiles() {
  // CSS index
  const cssIndex = `/**
 * @wex/design-tokens - Complete Theme Bundle
 *
 * This file imports all WEX design token layers:
 * 1. design-tokens.css - Core design tokens (palette, semantics)
 * 2. shadcn-bridge.css - shadcn/ui variable mappings
 * 3. components-bridge.css - Component-specific slot tokens
 *
 * Usage:
 *   import '@wex/design-tokens/css';
 */

@import './design-tokens.css';
@import './shadcn-bridge.css';
@import './components-bridge.css';
`;

  // SCSS index
  const scssIndex = `/**
 * @wex/design-tokens - Complete Theme Bundle (SCSS)
 *
 * This file imports all WEX design token layers:
 * 1. design-tokens.scss - Core design tokens (palette, semantics)
 * 2. shadcn-bridge.scss - shadcn/ui variable mappings
 * 3. components-bridge.scss - Component-specific slot tokens
 *
 * Usage:
 *   @import '@wex/design-tokens/scss';
 */

@import './design-tokens';
@import './shadcn-bridge';
@import './components-bridge';
`;

  fs.writeFileSync(path.join(CSS_DIR, 'index.css'), cssIndex);
  fs.writeFileSync(path.join(SCSS_DIR, 'index.scss'), scssIndex);
  
  // Generate root index.css as additional entry point
  const rootIndexCSS = `/**
 * @wex/design-tokens - Root Entry Point
 *
 * This file re-exports the CSS bundle from the css/ directory.
 * Provides an additional entry point at the package root.
 *
 * Usage:
 *   import '@wex/design-tokens';
 *   import '@wex/design-tokens/index.css';
 */

@import './css/index.css';
`;
  fs.writeFileSync(path.join(DESIGN_TOKENS_DIR, 'index.css'), rootIndexCSS);
}

// Run Style Dictionary for iOS/Android outputs
async function runStyleDictionary() {
  try {
    const configPath = path.join(DESIGN_TOKENS_DIR, 'style-dictionary.config.js');
    
    if (!fs.existsSync(configPath)) {
      console.warn('  ⚠ Style Dictionary config not found, skipping iOS/Android outputs');
      return;
    }

    // Ensure directories exist
    ensureDir(IOS_DIR);
    ensureDir(ANDROID_DIR);

    // Use child_process to run Style Dictionary CLI directly (more reliable)
    const { execSync } = require('child_process');
    const originalCwd = process.cwd();
    
    try {
      process.chdir(DESIGN_TOKENS_DIR);
      execSync('npx style-dictionary build --config style-dictionary.config.js', {
        stdio: 'pipe',
        encoding: 'utf8'
      });
      console.log('  ✓ Generated iOS outputs');
      console.log('  ✓ Generated Android outputs');
    } finally {
      process.chdir(originalCwd);
    }
  } catch (error) {
    console.warn(`  ⚠ Style Dictionary error: ${error.message}`);
    console.warn('  ⚠ Skipping iOS/Android outputs (this is optional)');
    // Don't fail the build if Style Dictionary fails - it's optional for now
  }
}

// Main build function
async function build() {
  console.log('Building @wex/design-tokens...');

  // Ensure directories exist
  ensureDir(CSS_DIR);
  ensureDir(SCSS_DIR);

  // Read theme
  const theme = readTheme();
  console.log(`  ✓ Read design-tokens.json (${Object.keys(theme.light).length} light tokens, ${Object.keys(theme.dark).length} dark tokens)`);

  // Generate design-tokens.css (renamed from tokens.css)
  const tokensCSS = generateCSS(theme);
  fs.writeFileSync(path.join(CSS_DIR, 'design-tokens.css'), tokensCSS);
  console.log('  ✓ Generated css/design-tokens.css');

  // Generate design-tokens.scss (renamed from tokens.scss)
  const tokensSCSS = generateSCSS(theme);
  fs.writeFileSync(path.join(SCSS_DIR, 'design-tokens.scss'), tokensSCSS);
  console.log('  ✓ Generated scss/design-tokens.scss');

  // Copy bridge files
  copyBridgeFiles();
  console.log('  ✓ Generated CSS and SCSS bridge files');

  // Generate index files
  generateIndexFiles();
  console.log('  ✓ Generated index.css and index.scss');

  // Generate TypeScript (renamed from tokens.ts)
  const tokensTS = generateTypeScript(theme);
  fs.writeFileSync(path.join(DESIGN_TOKENS_DIR, 'design-tokens.ts'), tokensTS);
  console.log('  ✓ Generated design-tokens.ts');

  // Note: design-tokens.json is the source file, we don't generate a separate output
  // Consumers can import the source JSON directly: import '@wex/design-tokens/json'
  console.log('  ✓ Using design-tokens.json as source (no separate JSON output needed)');

  // Run Style Dictionary for iOS/Android
  await runStyleDictionary();

  console.log('\n✓ Build complete!');
}

// Run build
(async () => {
  try {
    await build();
  } catch (error) {
    console.error('Error building tokens:', error);
    process.exit(1);
  }
})();
