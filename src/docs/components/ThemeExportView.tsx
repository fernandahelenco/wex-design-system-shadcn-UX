/**
 * Theme Export View Component
 * 
 * Inline export view within Theme Builder showing full token schema with syntax highlighting.
 */

import * as React from "react";
import { Copy, Download, Check } from "lucide-react";
import Prism from "prismjs";
import "prismjs/components/prism-css";
import "prismjs/components/prism-json";
// Prism theme will be applied via inline styles for better dark mode support
import { WexButton } from "@/components/wex";
import { cn } from "@/lib/utils";
import { useThemeOverrides } from "@/docs/hooks/useThemeOverrides";
import {
  PALETTE_RAMPS,
  SEMANTIC_TOKENS,
  SURFACE_TOKENS,
  TEXT_TOKENS,
  TYPOGRAPHY_TOKENS,
  ACCESSIBILITY_TOKENS,
  RADIUS_TOKENS,
  FOCUS_TOKENS,
  CHART_TOKENS,
  NEUTRAL_TOKENS,
  COMPONENT_TOKENS,
} from "@/docs/data/tokenRegistry";
import { parseHSL, formatHSL } from "@/docs/utils/color-convert";

// Standard lightness values for palette ramps
const PALETTE_LIGHTNESS_STEPS: Record<number, number> = {
  50: 97,
  100: 93,
  200: 85,
  300: 72,
  400: 56,
  500: 45,
  600: 38,
  700: 32,
  800: 26,
  900: 20,
};

/**
 * Generate full CSS with all tokens, applying overrides where they exist
 * Matches the exact structure of packages/design-tokens/dist/css/tokens.css
 */
function generateFullCSS(overrides: { light: Record<string, string>; dark: Record<string, string> }): string {
  const getTokenValue = (tokenName: string, defaultValue: string, mode: "light" | "dark"): string => {
    return overrides[mode][tokenName] || defaultValue;
  };

  const generateRampShades = (rampName: string, defaultHue: number, defaultSaturation: number, mode: "light" | "dark"): Record<string, string> => {
    const shades: Record<string, string> = {};
    const token500 = `--wex-palette-${rampName}-500`;
    
    const override500 = overrides[mode][token500];
    let rampHue = defaultHue;
    let rampSaturation = defaultSaturation;
    let baseLightness = PALETTE_LIGHTNESS_STEPS[500];
    
    if (override500) {
      const hsl = parseHSL(override500);
      if (hsl) {
        rampHue = hsl.h;
        rampSaturation = hsl.s;
        baseLightness = hsl.l;
      }
    }
    
    [50, 100, 200, 300, 400, 500, 600, 700, 800, 900].forEach((shade) => {
      const token = `--wex-palette-${rampName}-${shade}`;
      
      if (overrides[mode][token]) {
        shades[token] = overrides[mode][token];
      } else {
        const lightness = shade === 500 ? baseLightness : PALETTE_LIGHTNESS_STEPS[shade];
        shades[token] = formatHSL({ h: rampHue, s: rampSaturation, l: lightness });
      }
    });
    
    return shades;
  };

  // Generate purple ramp (not in PALETTE_RAMPS but exists in tokens.css)
  const generatePurpleRamp = (mode: "light" | "dark"): Record<string, string> => {
    return generateRampShades("purple", 270, 60, mode);
  };

  let css = "/* ============================================================\n";
  css += "   WEX TOKEN EMISSION LAYER\n";
  css += "   ============================================================\n";
  css += "   This file contains ALL WEX design tokens as CSS variables.\n";
  css += "   \n";
  css += "   FUTURE: This file will become a Style Dictionary generated output.\n";
  css += "   When that happens, this header will change to:\n";
  css += "   AUTO-GENERATED by Style Dictionary - DO NOT EDIT\n";
  css += "   ============================================================ */\n\n";

  css += ":root {\n";

  // Typography
  css += "  /* ===== TYPOGRAPHY (2 tokens) ===== */\n";
  TYPOGRAPHY_TOKENS.forEach((token) => {
    const value = getTokenValue(token.name, token.lightValue, "light");
    css += `  ${token.name}: ${value};\n`;
  });
  css += "\n";

  // Accessibility
  css += "  /* ===== ACCESSIBILITY (3 tokens) ===== */\n";
  ACCESSIBILITY_TOKENS.forEach((token) => {
    const value = getTokenValue(token.name, token.lightValue, "light");
    css += `  ${token.name}: ${value};\n`;
  });
  FOCUS_TOKENS.filter(t => t.name.includes("width") || t.name.includes("offset")).forEach((token) => {
    const value = getTokenValue(token.name, token.lightValue, "light");
    css += `  ${token.name}: ${value};\n`;
  });
  css += "\n";

  // Surfaces
  css += "  /* ===== SURFACES (3 tokens) - Now reference palette ===== */\n";
  SURFACE_TOKENS.forEach((token) => {
    const value = getTokenValue(token.name, token.lightValue, "light");
    css += `  ${token.name}: ${value};\n`;
  });
  css += "\n";

  // Text
  css += "  /* ===== TEXT (2 tokens) - Now reference palette ===== */\n";
  TEXT_TOKENS.forEach((token) => {
    const value = getTokenValue(token.name, token.lightValue, "light");
    css += `  ${token.name}: ${value};\n`;
  });
  css += "\n";

  // Brand
  const brandToken = SEMANTIC_TOKENS.find(t => t.name === "--wex-brand-red");
  if (brandToken) {
    css += "  /* ===== BRAND (1 token) ===== */\n";
    const value = getTokenValue(brandToken.name, brandToken.lightValue, "light");
    css += `  ${brandToken.name}: ${value}; /* #c8102e - Official WEX Logo Red */\n`;
    css += "\n";
  }

  // Primary
  css += "  /* ===== PRIMARY (4 tokens) ===== */\n";
  const primaryTokens = SEMANTIC_TOKENS.filter(t => t.name.includes("primary"));
  primaryTokens.forEach((token) => {
    const value = getTokenValue(token.name, token.lightValue, "light");
    css += `  ${token.name}: ${value};\n`;
  });
  css += "\n";

  // Link
  css += "  /* ===== LINK (3 tokens) - For text links on page backgrounds ===== */\n";
  const linkTokens = SEMANTIC_TOKENS.filter(t => t.name.includes("link"));
  linkTokens.forEach((token) => {
    const value = getTokenValue(token.name, token.lightValue, "light");
    css += `  ${token.name}: ${value};\n`;
  });
  css += "\n";

  // Input
  css += "  /* ===== INPUT (1 token) - Now references palette ===== */\n";
  const inputToken = SURFACE_TOKENS.find(t => t.name === "--wex-input-border");
  if (inputToken) {
    const value = getTokenValue(inputToken.name, inputToken.lightValue, "light");
    css += `  ${inputToken.name}: ${value};\n`;
  }
  css += "\n";

  // Focus Ring
  css += "  /* ===== FOCUS RING (1 token) ===== */\n";
  const focusRingColor = FOCUS_TOKENS.find(t => t.name === "--wex-focus-ring-color");
  if (focusRingColor) {
    const value = getTokenValue(focusRingColor.name, focusRingColor.lightValue, "light");
    css += `  ${focusRingColor.name}: ${value};\n`;
  }
  css += "\n";

  // Destructive
  css += "  /* ===== DESTRUCTIVE (3 tokens) ===== */\n";
  const destructiveTokens = SEMANTIC_TOKENS.filter(t => t.name.includes("destructive"));
  destructiveTokens.forEach((token) => {
    const value = getTokenValue(token.name, token.lightValue, "light");
    css += `  ${token.name}: ${value};\n`;
  });
  css += "\n";

  // Success
  css += "  /* ===== SUCCESS (3 tokens) ===== */\n";
  const successTokens = SEMANTIC_TOKENS.filter(t => t.name.includes("success"));
  successTokens.forEach((token) => {
    const value = getTokenValue(token.name, token.lightValue, "light");
    const comment = token.name === "--wex-success" ? " /* Darker for WCAG 4.5:1 text contrast */" : "";
    css += `  ${token.name}: ${value};${comment}\n`;
  });
  css += "\n";

  // Warning
  css += "  /* ===== WARNING (3 tokens) ===== */\n";
  const warningTokens = SEMANTIC_TOKENS.filter(t => t.name.includes("warning"));
  warningTokens.forEach((token) => {
    const value = getTokenValue(token.name, token.lightValue, "light");
    css += `  ${token.name}: ${value};\n`;
  });
  css += "\n";

  // Info
  css += "  /* ===== INFO (3 tokens) ===== */\n";
  const infoTokens = SEMANTIC_TOKENS.filter(t => t.name.includes("info"));
  infoTokens.forEach((token) => {
    const value = getTokenValue(token.name, token.lightValue, "light");
    const comment = token.name === "--wex-info" ? " /* Darker for WCAG 4.5:1 text contrast */" : "";
    css += `  ${token.name}: ${value};${comment}\n`;
  });
  css += "\n";

  // Highlight (hardcoded for now - not in registry)
  css += "  /* ===== HIGHLIGHT (4 tokens) =====\n";
  css += "     NOTE: *_alpha tokens are reserved for future utilities.\n";
  css += "     They must NOT be used via arbitrary color values or Tailwind utilities.\n";
  css += "     See WEX_COMPONENT_RULES.md Section 1.2 for rationale.\n";
  css += "     ===== */\n";
  const highlightTokens = ["--wex-highlight-bg", "--wex-highlight-bg-alpha", "--wex-highlight-fg", "--wex-highlight-fg-alpha"];
  const highlightDefaults = ["198 87% 97%", "1", "208 100% 32%", "1"];
  highlightTokens.forEach((token, idx) => {
    const value = getTokenValue(token, highlightDefaults[idx], "light");
    css += `  ${token}: ${value};\n`;
  });
  css += "\n";

  // Radius
  css += "  /* ===== RADII (3 tokens) ===== */\n";
  RADIUS_TOKENS.forEach((token) => {
    const value = getTokenValue(token.name, token.lightValue, "light");
    css += `  ${token.name}: ${value};\n`;
  });
  css += "\n";

  // Palette Ramps
  css += "  /* ===== PALETTE RAMPS (50-900 scales) =====\n";
  css += "     These are for subtle UI variations and should NOT be used\n";
  css += "     directly in components unless explicitly approved.\n";
  css += "     Use semantic tokens instead.\n";
  css += "     ===== */\n\n";

  // Generate ramps in order: blue, green, amber, red, slate, cyan, purple
  const rampOrder = ["blue", "green", "amber", "red", "slate", "cyan", "purple"];
  rampOrder.forEach((rampName) => {
    if (rampName === "purple") {
      const purpleShades = generatePurpleRamp("light");
      css += `  /* Purple ramp (derived from help) */\n`;
      [50, 100, 200, 300, 400, 500, 600, 700, 800, 900].forEach((shade) => {
        const token = `--wex-palette-purple-${shade}`;
        css += `  ${token}: ${purpleShades[token]};\n`;
      });
    } else {
      const ramp = PALETTE_RAMPS.find((r) => r.name === rampName);
      if (ramp) {
        const rampShades = generateRampShades(ramp.name, ramp.hue, ramp.saturation, "light");
        const rampLabel = ramp.label;
        const rampComment = rampName === "blue" ? " (derived from primary)" :
                           rampName === "green" ? " (derived from success)" :
                           rampName === "amber" ? " (derived from warning)" :
                           rampName === "red" ? " (derived from danger)" :
                           rampName === "slate" ? " (neutral, derived from text/surfaces)" :
                           rampName === "cyan" ? " (derived from info)" : "";
        css += `  /* ${rampLabel} ramp${rampComment} */\n`;
        [50, 100, 200, 300, 400, 500, 600, 700, 800, 900].forEach((shade) => {
          const token = `--wex-palette-${rampName}-${shade}`;
          css += `  ${token}: ${rampShades[token]};\n`;
        });
      }
    }
    css += "\n";
  });

  // Neutral extremes
  css += "  /* Neutral extremes (for backgrounds and text) */\n";
  NEUTRAL_TOKENS.forEach((neutral) => {
    const value = getTokenValue(neutral.token, neutral.value, "light");
    css += `  ${neutral.token}: ${value};\n`;
  });
  css += "\n";

  // Chart
  css += "  /* ===== CHART (5 tokens) =====\n";
  css += "     DESIGN GAP: These are placeholder values.\n";
  css += "     Brand team must define official chart colors.\n";
  css += "     Currently using primary and derived values as temporary placeholders.\n";
  css += "     ===== */\n";
  CHART_TOKENS.forEach((token) => {
    const value = getTokenValue(token.name, token.lightValue, "light");
    css += `  ${token.name}: ${value};\n`;
  });
  css += "}\n\n";

  // Dark mode
  css += ".dark {\n";

  // Surfaces (dark)
  css += "  /* ===== SURFACES (dark overrides) ===== */\n";
  SURFACE_TOKENS.forEach((token) => {
    const defaultValue = token.darkValue || token.lightValue;
    const value = getTokenValue(token.name, defaultValue, "dark");
    css += `  ${token.name}: ${value};\n`;
  });
  css += "\n";

  // Text (dark)
  css += "  /* ===== TEXT (dark overrides) ===== */\n";
  TEXT_TOKENS.forEach((token) => {
    const defaultValue = token.darkValue || token.lightValue;
    const value = getTokenValue(token.name, defaultValue, "dark");
    css += `  ${token.name}: ${value};\n`;
  });
  css += "\n";

  // Primary (dark)
  css += "  /* ===== PRIMARY (dark overrides) ===== */\n";
  css += "  /* Note: These values are used by button backgrounds - keep dark for white text contrast */\n";
  primaryTokens.forEach((token) => {
    const defaultValue = token.darkValue || token.lightValue;
    const value = getTokenValue(token.name, defaultValue, "dark");
    css += `  ${token.name}: ${value};\n`;
  });
  css += "\n";

  // Link (dark)
  css += "  /* ===== LINK (dark overrides) - Brighter for text visibility ===== */\n";
  linkTokens.forEach((token) => {
    const defaultValue = token.darkValue || token.lightValue;
    const value = getTokenValue(token.name, defaultValue, "dark");
    css += `  ${token.name}: ${value};\n`;
  });
  css += "\n";

  // Input (dark)
  css += "  /* ===== INPUT (dark override) ===== */\n";
  if (inputToken) {
    const defaultValue = inputToken.darkValue || inputToken.lightValue;
    const value = getTokenValue(inputToken.name, defaultValue, "dark");
    css += `  ${inputToken.name}: ${value};\n`;
  }
  css += "\n";

  // Focus Ring (dark)
  css += "  /* ===== FOCUS RING (dark override) ===== */\n";
  if (focusRingColor) {
    const defaultValue = focusRingColor.darkValue || focusRingColor.lightValue;
    const value = getTokenValue(focusRingColor.name, defaultValue, "dark");
    css += `  ${focusRingColor.name}: ${value};\n`;
  }
  css += "\n";

  // Destructive (dark)
  css += "  /* ===== DESTRUCTIVE (dark overrides) ===== */\n";
  destructiveTokens.forEach((token) => {
    const defaultValue = token.darkValue || token.lightValue;
    const value = getTokenValue(token.name, defaultValue, "dark");
    css += `  ${token.name}: ${value};\n`;
  });
  css += "\n";

  // Success (dark)
  css += "  /* ===== SUCCESS (dark overrides) ===== */\n";
  css += "  /* Note: These values are used by button backgrounds - keep dark for white text contrast */\n";
  successTokens.forEach((token) => {
    const defaultValue = token.darkValue || token.lightValue;
    const value = getTokenValue(token.name, defaultValue, "dark");
    css += `  ${token.name}: ${value};\n`;
  });
  css += "\n";

  // Warning (dark)
  css += "  /* ===== WARNING (dark overrides) ===== */\n";
  css += "  /* Note: Dark mode uses amber-400 (slightly lighter) for better contrast */\n";
  warningTokens.forEach((token) => {
    const defaultValue = token.darkValue || token.lightValue;
    const value = getTokenValue(token.name, defaultValue, "dark");
    css += `  ${token.name}: ${value};\n`;
  });
  css += "\n";

  // Info (dark)
  css += "  /* ===== INFO (dark overrides) ===== */\n";
  css += "  /* Note: These values are used by button backgrounds - keep dark for white text contrast */\n";
  infoTokens.forEach((token) => {
    const defaultValue = token.darkValue || token.lightValue;
    const value = getTokenValue(token.name, defaultValue, "dark");
    css += `  ${token.name}: ${value};\n`;
  });
  css += "\n";

  // Highlight (dark)
  css += "  /* ===== HIGHLIGHT (dark overrides) ===== */\n";
  const highlightDarkDefaults = ["201 74% 62%", "0.16", "0 0% 100%", "0.87"];
  highlightTokens.forEach((token, idx) => {
    const value = getTokenValue(token, highlightDarkDefaults[idx], "dark");
    css += `  ${token}: ${value};\n`;
  });
  css += "\n";

  // Chart (dark)
  css += "  /* ===== CHART (dark overrides) ===== */\n";
  CHART_TOKENS.forEach((token) => {
    const defaultValue = token.darkValue || token.lightValue;
    const value = getTokenValue(token.name, defaultValue, "dark");
    css += `  ${token.name}: ${value};\n`;
  });

  css += "}\n";

  return css;
}

/**
 * Generate shadcn-bridge.css
 * This file is static (hand-authored) and just references tokens
 */
function generateShadcnBridgeCSS(): string {
  // Read from source file - it's static and doesn't change based on overrides
  // Since it uses var() references, it automatically picks up token changes
  return `/* ============================================================
   SHADCN SEMANTIC BRIDGE
   ============================================================
   This file maps WEX tokens to shadcn semantic variables.
   
   This file is HAND-AUTHORED (semantic decisions require intent).
   It will NOT become a Style Dictionary output.
   
   RULES:
   - All values MUST reference --wex-* variables
   - NO raw HSL values allowed
   - State variants (hover, active) are included for Tailwind utilities
   ============================================================ */

:root {
  /* ===== BACKGROUNDS ===== */
  --background: var(--wex-content-bg);
  --foreground: var(--wex-text);

  /* ===== CARD ===== */
  --card: var(--wex-content-bg);
  --card-foreground: var(--wex-text);

  /* ===== POPOVER ===== */
  --popover: var(--wex-content-bg);
  --popover-foreground: var(--wex-text);

  /* ===== BRAND ===== */
  --brand-red: var(--wex-brand-red);

  /* ===== PRIMARY (with state) ===== */
  --primary: var(--wex-primary);
  --primary-foreground: var(--wex-primary-contrast);
  --primary-hover: var(--wex-primary-hover);

  /* ===== LINK (for text links) ===== */
  --link: var(--wex-link);
  --link-hover: var(--wex-link-hover);
  --link-active: var(--wex-link-active);

  /* ===== SECONDARY (with state) ===== */
  --secondary: var(--wex-content-border);
  --secondary-foreground: var(--wex-text);
  --secondary-hover: var(--wex-surface-subtle);

  /* ===== MUTED ===== */
  --muted: var(--wex-surface-subtle);
  --muted-foreground: var(--wex-text-muted);

  /* ===== ACCENT (subtle interactive hover surface) ===== */
  --accent: var(--wex-surface-subtle);
  --accent-foreground: var(--wex-text);

  /* ===== DESTRUCTIVE (with state) ===== */
  --destructive: var(--wex-destructive);
  --destructive-foreground: var(--wex-destructive-foreground);
  --destructive-hover: var(--wex-destructive-hover);

  /* ===== SUCCESS (with state) ===== */
  --success: var(--wex-success);
  --success-foreground: var(--wex-success-foreground);
  --success-hover: var(--wex-success-hover);

  /* ===== WARNING (with state) ===== */
  --warning: var(--wex-warning);
  --warning-foreground: var(--wex-warning-foreground);
  --warning-hover: var(--wex-warning-hover);

  /* ===== INFO (with state) ===== */
  --info: var(--wex-info);
  --info-foreground: var(--wex-info-foreground);
  --info-hover: var(--wex-info-hover);

  /* ===== BORDERS & INPUTS ===== */
  --border: var(--wex-content-border);
  --input: var(--wex-input-border);
  --ring: var(--wex-focus-ring-color);

  /* ===== RADII ===== */
  --radius: var(--wex-radius-md);

  /* ===== SIDEBAR (maps to existing surface tokens) ===== */
  --sidebar-background: var(--wex-content-bg);
  --sidebar-foreground: var(--wex-text);
  --sidebar-primary: var(--wex-primary);
  --sidebar-primary-foreground: var(--wex-primary-contrast);
  --sidebar-accent: var(--wex-surface-subtle);
  --sidebar-accent-foreground: var(--wex-text);
  --sidebar-border: var(--wex-content-border);
  --sidebar-ring: var(--wex-focus-ring-color);

  /* ===== CHART (placeholder - requires brand guidance) ===== */
  --chart-1: var(--wex-chart-1);
  --chart-2: var(--wex-chart-2);
  --chart-3: var(--wex-chart-3);
  --chart-4: var(--wex-chart-4);
  --chart-5: var(--wex-chart-5);
}

.dark {
  /* ===== SECONDARY (dark mode hover adjustment) ===== */
  --secondary-hover: var(--wex-content-border);
}
`;
}

/**
 * Generate components-bridge.css
 * Only outputs changed component tokens (those with overrides).
 * Full file is hand-authored, but we export only the changed tokens.
 */
function generateComponentsBridgeCSS(overrides: { light: Record<string, string>; dark: Record<string, string> }): string {
  // Get all component token overrides (tokens starting with --wex-component-)
  const componentOverrides = new Set<string>();
  
  Object.keys(overrides.light).forEach((token) => {
    if (token.startsWith("--wex-component-")) {
      componentOverrides.add(token);
    }
  });
  
  Object.keys(overrides.dark).forEach((token) => {
    if (token.startsWith("--wex-component-")) {
      componentOverrides.add(token);
    }
  });
  
  // If no component overrides, return a note
  if (componentOverrides.size === 0) {
    return `/* ============================================================
   WEX COMPONENT SLOT TOKENS (LAYER 3) - NO CHANGES
   ============================================================
   No component tokens were modified in this theme.
   ============================================================ */
`;
  }
  
  // Group tokens by component
  const tokensByComponent = new Map<string, Array<{ token: string; value: string }>>();
  
  componentOverrides.forEach((token) => {
    // Extract component name (e.g., "button", "card", "input")
    const match = token.match(/^--wex-component-(\w+)-/);
    if (match) {
      const component = match[1];
      if (!tokensByComponent.has(component)) {
        tokensByComponent.set(component, []);
      }
      const value = overrides.light[token] || overrides.dark[token] || "";
      tokensByComponent.get(component)!.push({ token, value });
    }
  });
  
  let css = `/* ============================================================
   WEX COMPONENT SLOT TOKENS (LAYER 3) - CHANGED TOKENS ONLY
   ============================================================
   This file contains only the component tokens that were modified.
   Add these to your wex.components-bridge.css file.
   ============================================================ */

:root {
`;
  
  // Output tokens grouped by component
  tokensByComponent.forEach((tokens, component) => {
    css += `  /* ===== ${component.toUpperCase()} ===== */\n`;
    tokens.forEach(({ token, value }) => {
      css += `  ${token}: ${value};\n`;
    });
    css += "\n";
  });
  
  css += `}

/* ============================================================
   DARK MODE OVERRIDES (if any)
   ============================================================ */

@media (prefers-color-scheme: dark) {
  :root {
`;
  
  // Output dark mode overrides
  let hasDarkOverrides = false;
  componentOverrides.forEach((token) => {
    if (overrides.dark[token] && overrides.dark[token] !== overrides.light[token]) {
      hasDarkOverrides = true;
      css += `    ${token}: ${overrides.dark[token]};\n`;
    }
  });
  
  if (!hasDarkOverrides) {
    css += `    /* No dark mode overrides for component tokens */\n`;
  }
  
  css += `  }
}
`;
  
  return css;
}

/**
 * Generate full JSON schema with all tokens
 */
function generateFullJSON(overrides: { light: Record<string, string>; dark: Record<string, string> }): string {
  const schema: Record<string, unknown> = { wex: {} };
  
  const getTokenValue = (tokenName: string, defaultValue: string, mode: "light" | "dark"): string => {
    return overrides[mode][tokenName] || defaultValue;
  };

  const generateRampShades = (rampName: string, defaultHue: number, defaultSaturation: number, mode: "light" | "dark"): Record<string, string> => {
    const shades: Record<string, string> = {};
    const token500 = `--wex-palette-${rampName}-500`;
    const override500 = overrides[mode][token500];
    let rampHue = defaultHue;
    let rampSaturation = defaultSaturation;
    let baseLightness = PALETTE_LIGHTNESS_STEPS[500];
    
    if (override500) {
      const hsl = parseHSL(override500);
      if (hsl) {
        rampHue = hsl.h;
        rampSaturation = hsl.s;
        baseLightness = hsl.l;
      }
    }
    
    [50, 100, 200, 300, 400, 500, 600, 700, 800, 900].forEach((shade) => {
      const token = `--wex-palette-${rampName}-${shade}`;
      
      if (overrides[mode][token]) {
        shades[token] = overrides[mode][token];
      } else {
        const lightness = shade === 500 ? baseLightness : PALETTE_LIGHTNESS_STEPS[shade];
        shades[token] = formatHSL({ h: rampHue, s: rampSaturation, l: lightness });
      }
    });
    
    return shades;
  };

  const setNestedProperty = (obj: Record<string, unknown>, path: string, value: unknown): void => {
    const keys = path.split(".");
    let current = obj;
    for (let i = 0; i < keys.length - 1; i++) {
      const key = keys[i];
      if (!(key in current) || typeof current[key] !== "object" || current[key] === null) {
        current[key] = {};
      }
      current = current[key] as Record<string, unknown>;
    }
    current[keys[keys.length - 1]] = value;
  };

  const processTokens = (mode: "light" | "dark", suffix = "") => {
    PALETTE_RAMPS.forEach((ramp) => {
      const rampShades = generateRampShades(ramp.name, ramp.hue, ramp.saturation, mode);
      Object.entries(rampShades).forEach(([token, value]) => {
        const cleanToken = token.replace("--wex-", "").replace(/-/g, ".");
        setNestedProperty(schema.wex as Record<string, unknown>, cleanToken + suffix, {
          value,
          type: "color",
        });
      });
    });

    NEUTRAL_TOKENS.forEach((neutral) => {
      const value = getTokenValue(neutral.token, neutral.value, mode);
      const cleanToken = neutral.token.replace("--wex-", "").replace(/-/g, ".");
      setNestedProperty(schema.wex as Record<string, unknown>, cleanToken + suffix, {
        value,
        type: "color",
      });
    });

    SEMANTIC_TOKENS.forEach((token) => {
      const defaultValue = mode === "dark" ? (token.darkValue || token.lightValue) : token.lightValue;
      const value = getTokenValue(token.name, defaultValue, mode);
      const cleanToken = token.name.replace("--wex-", "").replace(/-/g, ".");
      setNestedProperty(schema.wex as Record<string, unknown>, cleanToken + suffix, {
        value,
        type: "color",
      });
    });

    SURFACE_TOKENS.forEach((token) => {
      const defaultValue = mode === "dark" ? (token.darkValue || token.lightValue) : token.lightValue;
      const value = getTokenValue(token.name, defaultValue, mode);
      const cleanToken = token.name.replace("--wex-", "").replace(/-/g, ".");
      setNestedProperty(schema.wex as Record<string, unknown>, cleanToken + suffix, {
        value,
        type: "color",
      });
    });

    TEXT_TOKENS.forEach((token) => {
      const defaultValue = mode === "dark" ? (token.darkValue || token.lightValue) : token.lightValue;
      const value = getTokenValue(token.name, defaultValue, mode);
      const cleanToken = token.name.replace("--wex-", "").replace(/-/g, ".");
      setNestedProperty(schema.wex as Record<string, unknown>, cleanToken + suffix, {
        value,
        type: "color",
      });
    });

    // Layer 3 Component tokens
    COMPONENT_TOKENS.forEach((token) => {
      if (token.type === "color") {
        const defaultValue = mode === "dark" ? (token.darkValue || token.lightValue) : token.lightValue;
        const value = getTokenValue(token.name, defaultValue, mode);
        const cleanToken = token.name.replace("--wex-", "").replace(/-/g, ".");
        setNestedProperty(schema.wex as Record<string, unknown>, cleanToken + suffix, {
          value,
          type: "color",
        });
      }
    });
  };

  processTokens("light");
  processTokens("dark", ".dark");

  return JSON.stringify(schema, null, 2);
}

interface ThemeExportViewProps {
  onClose?: () => void;
}

export function ThemeExportView(_props: ThemeExportViewProps) {
  const { getAllOverrides } = useThemeOverrides();
  const overrides = getAllOverrides();
  const [copiedCSS, setCopiedCSS] = React.useState(false);
  const [copiedShadcn, setCopiedShadcn] = React.useState(false);
  const [copiedComponents, setCopiedComponents] = React.useState(false);
  const [copiedJSON, setCopiedJSON] = React.useState(false);
  const [activeTab, setActiveTab] = React.useState<"tokens" | "shadcn" | "components" | "json">("tokens");

  const tokensCSS = React.useMemo(() => generateFullCSS(overrides), [overrides]);
  const shadcnCSS = React.useMemo(() => generateShadcnBridgeCSS(), []);
  const componentsCSS = React.useMemo(() => generateComponentsBridgeCSS(overrides), [overrides]);
  const jsonCode = React.useMemo(() => generateFullJSON(overrides), [overrides]);

  // Generate highlighted HTML for CSS files
  const highlightedTokensCSS = React.useMemo(() => {
    try {
      return Prism.highlight(tokensCSS, Prism.languages.css, "css");
    } catch {
      return tokensCSS;
    }
  }, [tokensCSS]);

  const highlightedShadcnCSS = React.useMemo(() => {
    try {
      return Prism.highlight(shadcnCSS, Prism.languages.css, "css");
    } catch {
      return shadcnCSS;
    }
  }, [shadcnCSS]);

  const highlightedComponentsCSS = React.useMemo(() => {
    try {
      return Prism.highlight(componentsCSS, Prism.languages.css, "css");
    } catch {
      return componentsCSS;
    }
  }, [componentsCSS]);

  // Generate highlighted HTML for JSON
  const highlightedJSON = React.useMemo(() => {
    try {
      return Prism.highlight(jsonCode, Prism.languages.json, "json");
    } catch {
      return jsonCode;
    }
  }, [jsonCode]);

  const handleCopyTokens = React.useCallback(async () => {
    try {
      await navigator.clipboard.writeText(tokensCSS);
      setCopiedCSS(true);
      setTimeout(() => setCopiedCSS(false), 2000);
    } catch (err) {
      console.error("Failed to copy CSS:", err);
    }
  }, [tokensCSS]);

  const handleCopyShadcn = React.useCallback(async () => {
    try {
      await navigator.clipboard.writeText(shadcnCSS);
      setCopiedShadcn(true);
      setTimeout(() => setCopiedShadcn(false), 2000);
    } catch (err) {
      console.error("Failed to copy shadcn bridge:", err);
    }
  }, [shadcnCSS]);

  const handleCopyComponents = React.useCallback(async () => {
    try {
      await navigator.clipboard.writeText(componentsCSS);
      setCopiedComponents(true);
      setTimeout(() => setCopiedComponents(false), 2000);
    } catch (err) {
      console.error("Failed to copy components bridge:", err);
    }
  }, [componentsCSS]);

  const handleCopyJSON = React.useCallback(async () => {
    try {
      await navigator.clipboard.writeText(jsonCode);
      setCopiedJSON(true);
      setTimeout(() => setCopiedJSON(false), 2000);
    } catch (err) {
      console.error("Failed to copy JSON:", err);
    }
  }, [jsonCode]);

  const handleExportTokens = React.useCallback(() => {
    const blob = new Blob([tokensCSS], { type: "text/css" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "tokens.css";
    a.click();
    URL.revokeObjectURL(url);
  }, [tokensCSS]);

  const handleExportShadcn = React.useCallback(() => {
    const blob = new Blob([shadcnCSS], { type: "text/css" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "shadcn-bridge.css";
    a.click();
    URL.revokeObjectURL(url);
  }, [shadcnCSS]);

  const handleExportComponents = React.useCallback(() => {
    const blob = new Blob([componentsCSS], { type: "text/css" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "components-bridge.css";
    a.click();
    URL.revokeObjectURL(url);
  }, [componentsCSS]);

  const handleExportJSON = React.useCallback(() => {
    const blob = new Blob([jsonCode], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "wex-tokens.json";
    a.click();
    URL.revokeObjectURL(url);
  }, [jsonCode]);

  return (
    <>
      {/* Prism.js syntax highlighting styles - adapts to light/dark mode */}
      <style>{`
        /* Light mode colors - subtle, readable colors */
        .language-css .token.selector,
        .language-css .token.property,
        .language-css .token.function {
          color: #0066cc;
        }
        .language-css .token.string {
          color: #008000;
        }
        .language-css .token.punctuation {
          color: #666666;
        }
        .language-css .token.attr-name {
          color: #d97706;
        }
        .language-json .token.property {
          color: #0066cc;
        }
        .language-json .token.string {
          color: #008000;
        }
        .language-json .token.number {
          color: #dc2626;
        }
        .language-json .token.boolean {
          color: #0066cc;
        }
        .language-json .token.punctuation {
          color: #666666;
        }
        
        /* Dark mode colors - brighter, more vibrant */
        .dark .language-css .token.selector,
        .dark .language-css .token.property,
        .dark .language-css .token.function {
          color: #c792ea;
        }
        .dark .language-css .token.string {
          color: #c3e88d;
        }
        .dark .language-css .token.punctuation {
          color: #89ddff;
        }
        .dark .language-css .token.attr-name {
          color: #ffcb6b;
        }
        .dark .language-json .token.property {
          color: #c792ea;
        }
        .dark .language-json .token.string {
          color: #c3e88d;
        }
        .dark .language-json .token.number {
          color: #f78c6c;
        }
        .dark .language-json .token.boolean {
          color: #c792ea;
        }
        .dark .language-json .token.punctuation {
          color: #89ddff;
        }
      `}</style>
      <div className="h-full flex flex-col">
      {/* Tabs */}
      <div className="border-b border-border bg-muted/30">
        <div className="flex items-center gap-1 px-4">
          <button
            onClick={() => setActiveTab("tokens")}
            className={cn(
              "px-3 py-2 text-xs font-medium border-b-2 transition-colors",
              activeTab === "tokens"
                ? "border-primary text-foreground"
                : "border-transparent text-muted-foreground hover:text-foreground"
            )}
          >
            tokens.css
          </button>
          <button
            onClick={() => setActiveTab("shadcn")}
            className={cn(
              "px-3 py-2 text-xs font-medium border-b-2 transition-colors",
              activeTab === "shadcn"
                ? "border-primary text-foreground"
                : "border-transparent text-muted-foreground hover:text-foreground"
            )}
          >
            shadcn-bridge.css
          </button>
          <button
            onClick={() => setActiveTab("components")}
            className={cn(
              "px-3 py-2 text-xs font-medium border-b-2 transition-colors",
              activeTab === "components"
                ? "border-primary text-foreground"
                : "border-transparent text-muted-foreground hover:text-foreground"
            )}
          >
            components-bridge.css
          </button>
          <button
            onClick={() => setActiveTab("json")}
            className={cn(
              "px-3 py-2 text-xs font-medium border-b-2 transition-colors",
              activeTab === "json"
                ? "border-primary text-foreground"
                : "border-transparent text-muted-foreground hover:text-foreground"
            )}
          >
            tokens.json
          </button>
        </div>
      </div>

      {/* Content */}
      <div className="flex-1 overflow-y-auto px-6 py-6">
        <div className="max-w-7xl mx-auto">
          {/* Code Block */}
          <div className="rounded-lg border border-border bg-card overflow-hidden">
            <div className="flex items-center justify-between px-4 py-2 border-b border-border bg-muted/30">
              <div className="flex items-center gap-2">
                <span className="text-xs font-medium">
                  {activeTab === "tokens" && "tokens.css"}
                  {activeTab === "shadcn" && "shadcn-bridge.css"}
                  {activeTab === "components" && "components-bridge.css"}
                  {activeTab === "json" && "tokens.json"}
                </span>
                <span className="text-[10px] text-muted-foreground">
                  ({activeTab === "tokens" && tokensCSS.split("\n").length}
                  {activeTab === "shadcn" && shadcnCSS.split("\n").length}
                  {activeTab === "components" && componentsCSS.split("\n").length}
                  {activeTab === "json" && jsonCode.split("\n").length} lines)
                </span>
              </div>
              <div className="flex items-center gap-1">
                <WexButton
                  variant="ghost"
                  size="sm"
                  onClick={
                    activeTab === "tokens" ? handleCopyTokens :
                    activeTab === "shadcn" ? handleCopyShadcn :
                    activeTab === "components" ? handleCopyComponents :
                    handleCopyJSON
                  }
                  className="h-7 px-2"
                >
                  {(activeTab === "tokens" && copiedCSS) ||
                   (activeTab === "shadcn" && copiedShadcn) ||
                   (activeTab === "components" && copiedComponents) ||
                   (activeTab === "json" && copiedJSON) ? (
                    <Check className="h-3 w-3 text-success" />
                  ) : (
                    <Copy className="h-3 w-3" />
                  )}
                </WexButton>
                <WexButton
                  variant="ghost"
                  size="sm"
                  onClick={
                    activeTab === "tokens" ? handleExportTokens :
                    activeTab === "shadcn" ? handleExportShadcn :
                    activeTab === "components" ? handleExportComponents :
                    handleExportJSON
                  }
                  className="h-7 px-2"
                >
                  <Download className="h-3 w-3" />
                </WexButton>
              </div>
            </div>
            <div className="p-4 overflow-x-auto overflow-y-auto max-h-[500px] bg-muted/50 dark:bg-slate-950">
              <pre className="text-xs font-mono !m-0 !bg-transparent text-foreground dark:text-slate-100">
                <code 
                  className={cn(
                    activeTab === "json" ? "language-json" : "language-css",
                    "!text-sm !leading-relaxed"
                  )}
                  dangerouslySetInnerHTML={{ 
                    __html: activeTab === "tokens" ? highlightedTokensCSS :
                            activeTab === "shadcn" ? highlightedShadcnCSS :
                            activeTab === "components" ? highlightedComponentsCSS :
                            highlightedJSON
                  }}
                />
              </pre>
            </div>
          </div>
        </div>
      </div>
    </div>
    </>
  );
}

